

// This file was automatically generated by Coco/R; don't modify it.
#include "SdfParser.h"
#include "SdfErrors.h"
#include <QtDebug>
#include <QFileInfo>

namespace Sdf {


static QString coco_string_create( const wchar_t* str )
{
    return QString::fromStdWString(str);
}

int Parser::peek( quint8 la )
{
	if( la == 0 )
		return d_cur.d_type;
	else if( la == 1 )
		return d_next.d_type;
	else
		return scanner->peekToken( la - 1 ).d_type;
}


void Parser::SynErr(int n, const char* ctx) {
    if (errDist >= minErrDist)
    {
       SynErr(d_next.d_sourcePath,d_next.d_lineNr, d_next.d_colNr, n, errors, ctx);
    }
	errDist = 0;
}

void Parser::SemErr(const char* msg) {
	if (errDist >= minErrDist) errors->error(Sdf::Errors::Semantics,d_cur.d_sourcePath,d_cur.d_lineNr, d_cur.d_colNr, msg);
	errDist = 0;
}

void Parser::Get() {
	for (;;) {
		d_cur = d_next;
		d_next = scanner->nextToken();
        bool deliverToParser = false;
        switch( d_next.d_type )
        {
        case Sdf::Tok_Invalid:
        	if( !d_next.d_val.isEmpty() )
            	SynErr( d_next.d_type, d_next.d_val );
            // else errors already handeled in lexer
            break;
        case Sdf::Tok_Comment:
            d_comments.append(d_next);
            break;
        default:
            deliverToParser = true;
            break;
        }

        if( deliverToParser )
        {
            if( d_next.d_type == Sdf::Tok_Eof )
                d_next.d_type = _EOF;

            la->kind = d_next.d_type;
            if (la->kind <= maxT)
            {
                ++errDist;
                break;
            }
        }

		d_next = d_cur;
	}
}

void Parser::Expect(int n, const char* ctx ) {
	if (la->kind==n) Get(); else { SynErr(n, ctx); }
}

void Parser::ExpectWeak(int n, int follow) {
	if (la->kind == n) Get();
	else {
		SynErr(n);
		while (!StartOf(follow)) Get();
	}
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
	if (la->kind == n) {Get(); return true;}
	else if (StartOf(repFol)) {return false;}
	else {
		SynErr(n);
		while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
			Get();
		}
		return StartOf(syFol);
	}
}

void Parser::Sdf() {
		d_stack.push(&d_root); 
		delay_file();
		d_stack.pop(); 
}

void Parser::delay_file() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_delay_file, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_DELAYFILE,__FUNCTION__);
		addTerminal(); 
		sdf_header();
		cell();
		while (la->kind == _T_Lpar) {
			cell();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::sdf_header() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_sdf_header, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		sdf_version();
		if (peek(1) == _T_Lpar && peek(2) == _T_DESIGN ) {
			design_name();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_DATE ) {
			date();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_VENDOR ) {
			vendor();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_PROGRAM ) {
			program_name();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_VERSION ) {
			program_version();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_DIVIDER ) {
			hierarchy_divider();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_VOLTAGE ) {
			voltage();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_PROCESS ) {
			process();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_TEMPERATURE ) {
			temperature();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_TIMESCALE ) {
			time_scale();
		}
		d_stack.pop(); 
}

void Parser::cell() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_cell, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_CELL,__FUNCTION__);
		addTerminal(); 
		celltype();
		cell_instance();
		while (la->kind == _T_Lpar) {
			timing_spec();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::sdf_version() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_sdf_version, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_SDFVERSION,__FUNCTION__);
		addTerminal(); 
		qstring();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::design_name() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_design_name, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_DESIGN,__FUNCTION__);
		addTerminal(); 
		qstring();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::date() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_date, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_DATE,__FUNCTION__);
		addTerminal(); 
		qstring();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::vendor() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_vendor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_VENDOR,__FUNCTION__);
		addTerminal(); 
		qstring();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::program_name() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_program_name, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_PROGRAM,__FUNCTION__);
		addTerminal(); 
		qstring();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::program_version() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_program_version, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_VERSION,__FUNCTION__);
		addTerminal(); 
		qstring();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::hierarchy_divider() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_hierarchy_divider, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_DIVIDER,__FUNCTION__);
		addTerminal(); 
		hchar();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::voltage() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_voltage, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_VOLTAGE,__FUNCTION__);
		addTerminal(); 
		rnumber_or_rtriple_();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::process() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_process, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_PROCESS,__FUNCTION__);
		addTerminal(); 
		qstring();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::temperature() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_temperature, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_TEMPERATURE,__FUNCTION__);
		addTerminal(); 
		rnumber_or_rtriple_();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::time_scale() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_time_scale, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_TIMESCALE,__FUNCTION__);
		addTerminal(); 
		timescale_number();
		timescale_unit();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::qstring() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_qstring, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Str,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::hchar() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_hchar, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Dot) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Slash) {
			Get();
			addTerminal(); 
		} else SynErr(106,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::rnumber_or_rtriple_() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_rnumber_or_rtriple_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		signed_real_number();
		if (la->kind == _T_Comma || la->kind == _T_Colon) {
			if (la->kind == _T_Colon) {
				Get();
				addTerminal(); 
				if (StartOf(1)) {
					signed_real_number();
				}
				Expect(_T_Colon,__FUNCTION__);
				addTerminal(); 
				if (StartOf(1)) {
					signed_real_number();
				}
			} else {
				Get();
				addTerminal(); 
				signed_real_number();
				while (la->kind == _T_Comma) {
					Get();
					addTerminal(); 
					signed_real_number();
				}
			}
		}
		d_stack.pop(); 
}

void Parser::timescale_number() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_timescale_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Int) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Real) {
			Get();
			addTerminal(); 
		} else SynErr(107,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::timescale_unit() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_timescale_unit, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Ident,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::celltype() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_celltype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_CELLTYPE,__FUNCTION__);
		addTerminal(); 
		qstring();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::cell_instance() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_cell_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_INSTANCE,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Star || la->kind == _T_Ident) {
			if (la->kind == _T_Ident) {
				hierarchical_identifier();
			} else {
				Get();
				addTerminal(); 
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::timing_spec() {
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_DELAY) {
			del_spec();
		} else if (la->kind == _T_TIMINGCHECK) {
			tc_spec();
		} else if (la->kind == _T_LABEL) {
			lbl_spec();
		} else if (la->kind == _T_TIMINGENV) {
			te_spec();
		} else SynErr(108,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
}

void Parser::hierarchical_identifier() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_hierarchical_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		identifier();
		while (la->kind == _T_Dot || la->kind == _T_Slash) {
			hchar();
			identifier();
		}
		d_stack.pop(); 
}

void Parser::del_spec() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_del_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_DELAY,__FUNCTION__);
		addTerminal(); 
		deltype();
		while (la->kind == _T_Lpar) {
			deltype();
		}
		d_stack.pop(); 
}

void Parser::tc_spec() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_tc_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_TIMINGCHECK,__FUNCTION__);
		addTerminal(); 
		tchk_def();
		while (la->kind == _T_Lpar) {
			tchk_def();
		}
		d_stack.pop(); 
}

void Parser::lbl_spec() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_lbl_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_LABEL,__FUNCTION__);
		addTerminal(); 
		lbl_type();
		while (la->kind == _T_Lpar) {
			lbl_type();
		}
		d_stack.pop(); 
}

void Parser::te_spec() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_te_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_TIMINGENV,__FUNCTION__);
		addTerminal(); 
		te_def();
		while (la->kind == _T_Lpar) {
			te_def();
		}
		d_stack.pop(); 
}

void Parser::deltype() {
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_ABSOLUTE) {
			absolute_deltype();
		} else if (la->kind == _T_INCREMENT) {
			increment_deltype();
		} else if (la->kind == _T_PATHPULSE) {
			pathpulse_deltype();
		} else if (la->kind == _T_PATHPULSEPERCENT) {
			pathpulsepercent_deltype();
		} else SynErr(109,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
}

void Parser::tchk_def() {
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		switch (la->kind) {
		case _T_SETUP: {
			setup_timing_check();
			break;
		}
		case _T_HOLD: {
			hold_timing_check();
			break;
		}
		case _T_SETUPHOLD: {
			setuphold_timing_check();
			break;
		}
		case _T_RECOVERY: {
			recovery_timing_check();
			break;
		}
		case _T_REMOVAL: {
			removal_timing_check();
			break;
		}
		case _T_RECREM: {
			recrem_timing_check();
			break;
		}
		case _T_SKEW: {
			skew_timing_check();
			break;
		}
		case _T_BIDIRECTSKEW: {
			bidirectskew_timing_check();
			break;
		}
		case _T_WIDTH: {
			width_timing_check();
			break;
		}
		case _T_PERIOD: {
			period_timing_check();
			break;
		}
		case _T_NOCHANGE: {
			nochange_timing_check();
			break;
		}
		default: SynErr(110,__FUNCTION__); break;
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
}

void Parser::te_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_te_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(2)) {
			cns_def();
		} else if (StartOf(3)) {
			tenv_def();
		} else SynErr(111,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::lbl_type() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_lbl_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_INCREMENT) {
			Get();
			addTerminal(); 
			lbl_def();
			while (la->kind == _T_Lpar) {
				lbl_def();
			}
		} else if (la->kind == _T_ABSOLUTE) {
			Get();
			addTerminal(); 
			lbl_def();
			while (la->kind == _T_Lpar) {
				lbl_def();
			}
		} else SynErr(112,__FUNCTION__);
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::absolute_deltype() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_absolute_deltype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_ABSOLUTE,__FUNCTION__);
		addTerminal(); 
		del_def();
		while (la->kind == _T_Lpar) {
			del_def();
		}
		d_stack.pop(); 
}

void Parser::increment_deltype() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_increment_deltype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_INCREMENT,__FUNCTION__);
		addTerminal(); 
		del_def();
		while (la->kind == _T_Lpar) {
			del_def();
		}
		d_stack.pop(); 
}

void Parser::pathpulse_deltype() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_pathpulse_deltype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_PATHPULSE,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Ident) {
			input_output_path();
		}
		value();
		if (la->kind == _T_Lpar) {
			value();
		}
		d_stack.pop(); 
}

void Parser::pathpulsepercent_deltype() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_pathpulsepercent_deltype, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_PATHPULSEPERCENT,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Ident) {
			input_output_path();
		}
		value();
		if (la->kind == _T_Lpar) {
			value();
		}
		d_stack.pop(); 
}

void Parser::input_output_path() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_input_output_path, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_instance();
		port_instance();
		d_stack.pop(); 
}

void Parser::value() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(1)) {
			rnumber_or_rtriple_();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::del_def() {
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		switch (la->kind) {
		case _T_IOPATH: {
			iopath_def();
			break;
		}
		case _T_COND: {
			cond_def();
			break;
		}
		case _T_CONDELSE: {
			condelse_def();
			break;
		}
		case _T_PORT: {
			port_def();
			break;
		}
		case _T_INTERCONNECT: {
			interconnect_def();
			break;
		}
		case _T_NETDELAY: {
			netdelay_def();
			break;
		}
		case _T_DEVICE: {
			device_def();
			break;
		}
		default: SynErr(113,__FUNCTION__); break;
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
}

void Parser::port_instance() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_port_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		hierarchical_identifier();
		if (la->kind == _T_Dot || la->kind == _T_Slash || la->kind == _T_Lbrack) {
			if (la->kind == _T_Lbrack) {
				Get();
				addTerminal(); 
				integer();
				if (la->kind == _T_Colon) {
					Get();
					addTerminal(); 
					integer();
				}
				Expect(_T_Rbrack,__FUNCTION__);
				addTerminal(); 
			} else {
				hchar();
				port();
			}
		}
		d_stack.pop(); 
}

void Parser::iopath_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_iopath_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_IOPATH,__FUNCTION__);
		addTerminal(); 
		port_spec();
		port_instance();
		while (la->kind == _T_RETAIN) {
			retain_def();
		}
		delval_list();
		d_stack.pop(); 
}

void Parser::cond_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_cond_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_COND,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Str) {
			qstring();
		}
		conditional_port_expr();
		while (StartOf(4)) {
			if (StartOf(5)) {
				conditional_port_expr();
			} else {
				concat_expression();
			}
		}
		iopath_def();
		d_stack.pop(); 
}

void Parser::condelse_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_condelse_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_CONDELSE,__FUNCTION__);
		addTerminal(); 
		iopath_def();
		d_stack.pop(); 
}

void Parser::port_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_port_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_PORT,__FUNCTION__);
		addTerminal(); 
		port_instance();
		delval_list();
		d_stack.pop(); 
}

void Parser::interconnect_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_interconnect_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_INTERCONNECT,__FUNCTION__);
		addTerminal(); 
		port_instance();
		port_instance();
		delval_list();
		d_stack.pop(); 
}

void Parser::netdelay_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_netdelay_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_NETDELAY,__FUNCTION__);
		addTerminal(); 
		net_spec();
		delval_list();
		d_stack.pop(); 
}

void Parser::device_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_device_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_DEVICE,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Ident) {
			port_instance();
		}
		delval_list();
		d_stack.pop(); 
}

void Parser::port_spec() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_port_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			port_instance();
		} else if (la->kind == _T_Lpar) {
			port_edge();
		} else SynErr(114,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::retain_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_retain_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_RETAIN,__FUNCTION__);
		addTerminal(); 
		retval_list();
		d_stack.pop(); 
}

void Parser::delval_list() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_delval_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		delval();
		while (la->kind == _T_Lpar) {
			delval();
		}
		d_stack.pop(); 
}

void Parser::retval_list() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_retval_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		delval();
		while (la->kind == _T_Lpar) {
			delval();
		}
		d_stack.pop(); 
}

void Parser::conditional_port_expr() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_conditional_port_expr, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Lpar) {
			Get();
			addTerminal(); 
			conditional_port_expr();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
			conditional_port_expr_nlr_();
		} else if (StartOf(6)) {
			unary_operator();
			if (la->kind == _T_Ident) {
				port();
			} else if (la->kind == _T_Int) {
				scalar_constant();
			} else if (la->kind == _T_Lpar) {
				Get();
				addTerminal(); 
				conditional_port_expr();
				Expect(_T_Rpar,__FUNCTION__);
				addTerminal(); 
			} else SynErr(115,__FUNCTION__);
			conditional_port_expr_nlr_();
		} else if (la->kind == _T_Ident) {
			port();
			conditional_port_expr_nlr_();
		} else if (la->kind == _T_Int) {
			scalar_constant();
			conditional_port_expr_nlr_();
		} else SynErr(116,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::concat_expression() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_concat_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Comma,__FUNCTION__);
		addTerminal(); 
		conditional_port_expr();
		d_stack.pop(); 
}

void Parser::net_spec() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_net_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_instance();
		d_stack.pop(); 
}

void Parser::setup_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_setup_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SETUP,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		value();
		d_stack.pop(); 
}

void Parser::hold_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_hold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_HOLD,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		value();
		d_stack.pop(); 
}

void Parser::setuphold_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_setuphold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SETUPHOLD,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		rvalue();
		rvalue();
		if (peek(1) == _T_Lpar && peek(2) == _T_SCOND ) {
			scond();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_CCOND ) {
			ccond();
		}
		d_stack.pop(); 
}

void Parser::recovery_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_recovery_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_RECOVERY,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		value();
		d_stack.pop(); 
}

void Parser::removal_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_removal_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_REMOVAL,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		value();
		d_stack.pop(); 
}

void Parser::recrem_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_recrem_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_RECREM,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		rvalue();
		rvalue();
		if (peek(1) == _T_Lpar && peek(2) == _T_SCOND ) {
			scond();
		}
		if (peek(1) == _T_Lpar && peek(2) == _T_CCOND ) {
			ccond();
		}
		d_stack.pop(); 
}

void Parser::skew_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_skew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SKEW,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		rvalue();
		d_stack.pop(); 
}

void Parser::bidirectskew_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_bidirectskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_BIDIRECTSKEW,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		value();
		value();
		d_stack.pop(); 
}

void Parser::width_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_width_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_WIDTH,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		value();
		d_stack.pop(); 
}

void Parser::period_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_period_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_PERIOD,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		value();
		d_stack.pop(); 
}

void Parser::nochange_timing_check() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_nochange_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_NOCHANGE,__FUNCTION__);
		addTerminal(); 
		port_tchk();
		port_tchk();
		rvalue();
		rvalue();
		d_stack.pop(); 
}

void Parser::port_tchk() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_port_tchk, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (peek(1) == _T_Lpar && peek(2) == _T_COND ) {
			Expect(_T_Lpar,__FUNCTION__);
			addTerminal(); 
			Expect(_T_COND,__FUNCTION__);
			addTerminal(); 
			if (la->kind == _T_Str) {
				qstring();
			}
			timing_check_condition();
			port_spec();
			Expect(_T_Rpar,__FUNCTION__);
			addTerminal(); 
		} else if (la->kind == _T_Lpar || la->kind == _T_Ident) {
			port_spec();
		} else SynErr(117,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::rvalue() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_rvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(1)) {
			rnumber_or_rtriple_();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::scond() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_scond, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_SCOND,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Str) {
			qstring();
		}
		timing_check_condition();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::ccond() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_ccond, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_CCOND,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Str) {
			qstring();
		}
		timing_check_condition();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::timing_check_condition() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_timing_check_condition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Ident) {
			scalar_node();
			if (StartOf(7)) {
				equality_operator();
				scalar_constant();
			}
		} else if (la->kind == _T_Bang || la->kind == _T_Tilde) {
			inversion_operator();
			scalar_node();
		} else SynErr(118,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::cns_def() {
		if (la->kind == _T_PATHCONSTRAINT) {
			path_constraint();
		} else if (la->kind == _T_PERIODCONSTRAINT) {
			period_constraint();
		} else if (la->kind == _T_SUM) {
			sum_constraint();
		} else if (la->kind == _T_DIFF) {
			diff_constraint();
		} else if (la->kind == _T_SKEWCONSTRAINT) {
			skew_constraint();
		} else SynErr(119,__FUNCTION__);
}

void Parser::tenv_def() {
		if (la->kind == _T_ARRIVAL) {
			arrival_env();
		} else if (la->kind == _T_DEPARTURE) {
			departure_env();
		} else if (la->kind == _T_SLACK) {
			slack_env();
		} else if (la->kind == _T_WAVEFORM) {
			waveform_env();
		} else SynErr(120,__FUNCTION__);
}

void Parser::path_constraint() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_path_constraint, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_PATHCONSTRAINT,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			name();
		}
		port_instance();
		port_instance();
		while (la->kind == _T_Ident) {
			port_instance();
		}
		rvalue();
		rvalue();
		d_stack.pop(); 
}

void Parser::period_constraint() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_period_constraint, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_PERIODCONSTRAINT,__FUNCTION__);
		addTerminal(); 
		port_instance();
		value();
		if (la->kind == _T_Lpar) {
			exception();
		}
		d_stack.pop(); 
}

void Parser::sum_constraint() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_sum_constraint, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SUM,__FUNCTION__);
		addTerminal(); 
		constraint_path();
		constraint_path();
		while (peek(1) == _T_Lpar && peek(2) == _T_Ident ) {
			constraint_path();
		}
		rvalue();
		if (la->kind == _T_Lpar) {
			rvalue();
		}
		d_stack.pop(); 
}

void Parser::diff_constraint() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_diff_constraint, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_DIFF,__FUNCTION__);
		addTerminal(); 
		constraint_path();
		constraint_path();
		value();
		if (la->kind == _T_Lpar) {
			value();
		}
		d_stack.pop(); 
}

void Parser::skew_constraint() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_skew_constraint, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SKEWCONSTRAINT,__FUNCTION__);
		addTerminal(); 
		port_spec();
		value();
		d_stack.pop(); 
}

void Parser::name() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_name, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_NAME,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Str) {
			qstring();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::exception() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_exception, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		Expect(_T_EXCEPTION,__FUNCTION__);
		addTerminal(); 
		cell_instance();
		while (la->kind == _T_Lpar) {
			cell_instance();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::constraint_path() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_constraint_path, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		port_instance();
		port_instance();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::arrival_env() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_arrival_env, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_ARRIVAL,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			port_edge();
		}
		port_instance();
		rvalue();
		rvalue();
		rvalue();
		rvalue();
		d_stack.pop(); 
}

void Parser::departure_env() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_departure_env, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_DEPARTURE,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_Lpar) {
			port_edge();
		}
		port_instance();
		rvalue();
		rvalue();
		rvalue();
		rvalue();
		d_stack.pop(); 
}

void Parser::slack_env() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_slack_env, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_SLACK,__FUNCTION__);
		addTerminal(); 
		port_instance();
		rvalue();
		rvalue();
		rvalue();
		rvalue();
		if (la->kind == _T_Int || la->kind == _T_Real) {
			real_number();
		}
		d_stack.pop(); 
}

void Parser::waveform_env() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_waveform_env, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_WAVEFORM,__FUNCTION__);
		addTerminal(); 
		port_instance();
		real_number();
		edge_list();
		d_stack.pop(); 
}

void Parser::port_edge() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_port_edge, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		edge_identifier();
		port_instance();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::real_number() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_real_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Real) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Int) {
			Get();
			addTerminal(); 
		} else SynErr(121,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::edge_list() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_edge_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		pos_or_neg_pair_();
		while (la->kind == _T_Lpar) {
			pos_or_neg_pair_();
		}
		d_stack.pop(); 
}

void Parser::pos_or_neg_pair_() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_pos_or_neg_pair_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (la->kind == _T_posedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_negedge) {
			Get();
			addTerminal(); 
		} else SynErr(122,__FUNCTION__);
		signed_real_number();
		if (StartOf(1)) {
			signed_real_number();
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::signed_real_number() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_signed_real_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus || la->kind == _T_Minus) {
			sign();
		}
		real_number();
		d_stack.pop(); 
}

void Parser::lbl_def() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_lbl_def, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		identifier();
		delval_list();
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::identifier() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Ident,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::edge_identifier() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_edge_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_posedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_negedge) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Int) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Ident) {
			Get();
			addTerminal(); 
		} else SynErr(123,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::integer() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_integer, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Int,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::port() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_port, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_or_net_();
		d_stack.pop(); 
}

void Parser::port_or_net_() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_port_or_net_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		hierarchical_identifier();
		Expect(_T_Lbrack,__FUNCTION__);
		addTerminal(); 
		integer();
		if (la->kind == _T_Colon) {
			Get();
			addTerminal(); 
			integer();
		}
		Expect(_T_Rbrack,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::delval() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_delval, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Lpar,__FUNCTION__);
		addTerminal(); 
		if (StartOf(8)) {
			if (StartOf(1)) {
				rnumber_or_rtriple_();
			} else {
				rvalue();
				while (la->kind == _T_Lpar) {
					rvalue();
				}
			}
		}
		Expect(_T_Rpar,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::conditional_port_expr_nlr_() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_conditional_port_expr_nlr_, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (StartOf(9)) {
			if (la->kind == _T_Qmark) {
				Get();
				addTerminal(); 
				conditional_port_expr();
				Expect(_T_Colon,__FUNCTION__);
				addTerminal(); 
				conditional_port_expr();
			} else {
				binary_operator();
				conditional_port_expr();
			}
			conditional_port_expr_nlr_();
		}
		d_stack.pop(); 
}

void Parser::unary_operator() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_unary_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Plus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Minus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bang: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Tilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeAmp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeBar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Hat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_HatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(124,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::scalar_constant() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_scalar_constant, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		Expect(_T_Int,__FUNCTION__);
		addTerminal(); 
		d_stack.pop(); 
}

void Parser::binary_operator() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_binary_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		switch (la->kind) {
		case _T_Plus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Minus: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Star: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Slash: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Percent: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_BangEq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_3Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bang2Eq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Lt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Leq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Geq: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Amp: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Bar: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_Hat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_HatTilde: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_TildeHat: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Gt: {
			Get();
			addTerminal(); 
			break;
		}
		case _T_2Lt: {
			Get();
			addTerminal(); 
			break;
		}
		default: SynErr(125,__FUNCTION__); break;
		}
		d_stack.pop(); 
}

void Parser::scalar_node() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_scalar_node, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		port_or_net_();
		d_stack.pop(); 
}

void Parser::equality_operator() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_equality_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_2Eq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_BangEq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_3Eq) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Bang2Eq) {
			Get();
			addTerminal(); 
		} else SynErr(126,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::inversion_operator() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_inversion_operator, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Bang) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Tilde) {
			Get();
			addTerminal(); 
		} else SynErr(127,__FUNCTION__);
		d_stack.pop(); 
}

void Parser::sign() {
		Sdf::SynTree* n = new Sdf::SynTree( Sdf::SynTree::R_sign, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); 
		if (la->kind == _T_Plus) {
			Get();
			addTerminal(); 
		} else if (la->kind == _T_Minus) {
			Get();
			addTerminal(); 
		} else SynErr(128,__FUNCTION__);
		d_stack.pop(); 
}




// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
	template<typename U, void (U::*)() = &U::Init>
	struct ExistsIfInitIsDefinedMarker{};

	struct InitIsMissingType {
		char dummy1;
	};
	
	struct InitExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static InitIsMissingType is_here(...);

	// exist only if ExistsIfInitIsDefinedMarker is defined
	template<typename U>
	static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

	enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
	template<typename U, void (U::*)() = &U::Destroy>
	struct ExistsIfDestroyIsDefinedMarker{};

	struct DestroyIsMissingType {
		char dummy1;
	};
	
	struct DestroyExistsType {
		char dummy1; char dummy2;
	};

	// exists always
	template<typename U>
	static DestroyIsMissingType is_here(...);

	// exist only if ExistsIfDestroyIsDefinedMarker is defined
	template<typename U>
	static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

	enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
	static void CallInit(T *t) {
		// nothing to do
	}
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
	static void CallInit(T *t) {
		t->Init();
	}
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
	static void CallDestroy(T *t) {
		// nothing to do
	}
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
	static void CallDestroy(T *t) {
		t->Destroy();
	}
};

void Parser::Parse() {
	d_cur = Sdf::Token();
	d_next = Sdf::Token();
	Get();
	Sdf();
	Expect(0,__FUNCTION__);
}

Parser::Parser(Sdf::Lexer *scanner, Sdf::Errors* err) {
	maxT = 105;

	ParserInitCaller<Parser>::CallInit(this);
	la = &d_dummy;
	minErrDist = 2;
	errDist = minErrDist;
	this->scanner = scanner;
	errors = err;
}

bool Parser::StartOf(int s) {
	const bool T = true;
	const bool x = false;

	static bool set[10][107] = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,T,x, x,x,T,x, T,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,x,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x},
		{x,x,T,x, x,x,T,x, T,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,x,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x},
		{x,x,T,x, x,x,T,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,x,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
		{x,x,x,x, x,x,x,x, T,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x},
		{x,x,x,T, T,T,T,T, x,x,T,x, T,x,T,x, T,x,x,x, T,T,T,T, T,T,T,T, T,x,x,T, T,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x}
	};



	return set[s][la->kind];
}

Parser::~Parser() {
	ParserDestroyCaller<Parser>::CallDestroy(this);
}

void Parser::SynErr(const QString& sourcePath, int line, int col, int n, Sdf::Errors* err, const char* ctx, const QString& str ) {
	QString s;
	QString ctxStr;
	if( ctx )
		ctxStr = QString( " in %1" ).arg(ctx);
    if( n == 0 )
        s = QString("EOF expected%1").arg(ctxStr);
    else if( n < Sdf::TT_Specials )
        s = QString("'%2' expected%1").arg(ctxStr).arg(Sdf::tokenTypeString(n));
    else if( n <= Sdf::TT_Max )
        s = QString("%2 expected%1").arg(ctxStr).arg(Sdf::tokenTypeString(n));
    else
	switch (n) {
			case 0: s = coco_string_create(L"EOF expected"); break;
			case 1: s = coco_string_create(L"T_Literals_ expected"); break;
			case 2: s = coco_string_create(L"T_Bang expected"); break;
			case 3: s = coco_string_create(L"T_BangEq expected"); break;
			case 4: s = coco_string_create(L"T_Bang2Eq expected"); break;
			case 5: s = coco_string_create(L"T_Percent expected"); break;
			case 6: s = coco_string_create(L"T_Amp expected"); break;
			case 7: s = coco_string_create(L"T_2Amp expected"); break;
			case 8: s = coco_string_create(L"T_Lpar expected"); break;
			case 9: s = coco_string_create(L"T_Rpar expected"); break;
			case 10: s = coco_string_create(L"T_Star expected"); break;
			case 11: s = coco_string_create(L"T_Rcmt expected"); break;
			case 12: s = coco_string_create(L"T_Plus expected"); break;
			case 13: s = coco_string_create(L"T_Comma expected"); break;
			case 14: s = coco_string_create(L"T_Minus expected"); break;
			case 15: s = coco_string_create(L"T_Dot expected"); break;
			case 16: s = coco_string_create(L"T_Slash expected"); break;
			case 17: s = coco_string_create(L"T_Lcmt expected"); break;
			case 18: s = coco_string_create(L"T_2Slash expected"); break;
			case 19: s = coco_string_create(L"T_Colon expected"); break;
			case 20: s = coco_string_create(L"T_Lt expected"); break;
			case 21: s = coco_string_create(L"T_2Lt expected"); break;
			case 22: s = coco_string_create(L"T_Leq expected"); break;
			case 23: s = coco_string_create(L"T_2Eq expected"); break;
			case 24: s = coco_string_create(L"T_3Eq expected"); break;
			case 25: s = coco_string_create(L"T_Gt expected"); break;
			case 26: s = coco_string_create(L"T_Geq expected"); break;
			case 27: s = coco_string_create(L"T_2Gt expected"); break;
			case 28: s = coco_string_create(L"T_Qmark expected"); break;
			case 29: s = coco_string_create(L"T_Lbrack expected"); break;
			case 30: s = coco_string_create(L"T_Rbrack expected"); break;
			case 31: s = coco_string_create(L"T_Hat expected"); break;
			case 32: s = coco_string_create(L"T_HatTilde expected"); break;
			case 33: s = coco_string_create(L"T_Bar expected"); break;
			case 34: s = coco_string_create(L"T_2Bar expected"); break;
			case 35: s = coco_string_create(L"T_Tilde expected"); break;
			case 36: s = coco_string_create(L"T_TildeAmp expected"); break;
			case 37: s = coco_string_create(L"T_TildeHat expected"); break;
			case 38: s = coco_string_create(L"T_TildeBar expected"); break;
			case 39: s = coco_string_create(L"T_Keywords_ expected"); break;
			case 40: s = coco_string_create(L"T_ABSOLUTE expected"); break;
			case 41: s = coco_string_create(L"T_ARRIVAL expected"); break;
			case 42: s = coco_string_create(L"T_BIDIRECTSKEW expected"); break;
			case 43: s = coco_string_create(L"T_CCOND expected"); break;
			case 44: s = coco_string_create(L"T_CELL expected"); break;
			case 45: s = coco_string_create(L"T_CELLTYPE expected"); break;
			case 46: s = coco_string_create(L"T_COND expected"); break;
			case 47: s = coco_string_create(L"T_CONDELSE expected"); break;
			case 48: s = coco_string_create(L"T_DATE expected"); break;
			case 49: s = coco_string_create(L"T_DELAY expected"); break;
			case 50: s = coco_string_create(L"T_DELAYFILE expected"); break;
			case 51: s = coco_string_create(L"T_DEPARTURE expected"); break;
			case 52: s = coco_string_create(L"T_DESIGN expected"); break;
			case 53: s = coco_string_create(L"T_DEVICE expected"); break;
			case 54: s = coco_string_create(L"T_DIFF expected"); break;
			case 55: s = coco_string_create(L"T_DIVIDER expected"); break;
			case 56: s = coco_string_create(L"T_EXCEPTION expected"); break;
			case 57: s = coco_string_create(L"T_HOLD expected"); break;
			case 58: s = coco_string_create(L"T_INCREMENT expected"); break;
			case 59: s = coco_string_create(L"T_INSTANCE expected"); break;
			case 60: s = coco_string_create(L"T_INTERCONNECT expected"); break;
			case 61: s = coco_string_create(L"T_IOPATH expected"); break;
			case 62: s = coco_string_create(L"T_LABEL expected"); break;
			case 63: s = coco_string_create(L"T_NAME expected"); break;
			case 64: s = coco_string_create(L"T_NETDELAY expected"); break;
			case 65: s = coco_string_create(L"T_NOCHANGE expected"); break;
			case 66: s = coco_string_create(L"T_PATHCONSTRAINT expected"); break;
			case 67: s = coco_string_create(L"T_PATHPULSE expected"); break;
			case 68: s = coco_string_create(L"T_PATHPULSEPERCENT expected"); break;
			case 69: s = coco_string_create(L"T_PERIOD expected"); break;
			case 70: s = coco_string_create(L"T_PERIODCONSTRAINT expected"); break;
			case 71: s = coco_string_create(L"T_PORT expected"); break;
			case 72: s = coco_string_create(L"T_PROCESS expected"); break;
			case 73: s = coco_string_create(L"T_PROGRAM expected"); break;
			case 74: s = coco_string_create(L"T_RECOVERY expected"); break;
			case 75: s = coco_string_create(L"T_RECREM expected"); break;
			case 76: s = coco_string_create(L"T_REMOVAL expected"); break;
			case 77: s = coco_string_create(L"T_RETAIN expected"); break;
			case 78: s = coco_string_create(L"T_SCOND expected"); break;
			case 79: s = coco_string_create(L"T_SDFVERSION expected"); break;
			case 80: s = coco_string_create(L"T_SETUP expected"); break;
			case 81: s = coco_string_create(L"T_SETUPHOLD expected"); break;
			case 82: s = coco_string_create(L"T_SKEW expected"); break;
			case 83: s = coco_string_create(L"T_SKEWCONSTRAINT expected"); break;
			case 84: s = coco_string_create(L"T_SLACK expected"); break;
			case 85: s = coco_string_create(L"T_SUM expected"); break;
			case 86: s = coco_string_create(L"T_TEMPERATURE expected"); break;
			case 87: s = coco_string_create(L"T_TIMESCALE expected"); break;
			case 88: s = coco_string_create(L"T_TIMINGCHECK expected"); break;
			case 89: s = coco_string_create(L"T_TIMINGENV expected"); break;
			case 90: s = coco_string_create(L"T_VENDOR expected"); break;
			case 91: s = coco_string_create(L"T_VERSION expected"); break;
			case 92: s = coco_string_create(L"T_VOLTAGE expected"); break;
			case 93: s = coco_string_create(L"T_WAVEFORM expected"); break;
			case 94: s = coco_string_create(L"T_WIDTH expected"); break;
			case 95: s = coco_string_create(L"T_negedge expected"); break;
			case 96: s = coco_string_create(L"T_posedge expected"); break;
			case 97: s = coco_string_create(L"T_Specials_ expected"); break;
			case 98: s = coco_string_create(L"T_Ident expected"); break;
			case 99: s = coco_string_create(L"T_Int expected"); break;
			case 100: s = coco_string_create(L"T_Str expected"); break;
			case 101: s = coco_string_create(L"T_Real expected"); break;
			case 102: s = coco_string_create(L"T_Comment expected"); break;
			case 103: s = coco_string_create(L"T_Eof expected"); break;
			case 104: s = coco_string_create(L"T_MaxToken_ expected"); break;
			case 105: s = coco_string_create(L"??? expected"); break;
			case 106: s = coco_string_create(L"invalid hchar"); break;
			case 107: s = coco_string_create(L"invalid timescale_number"); break;
			case 108: s = coco_string_create(L"invalid timing_spec"); break;
			case 109: s = coco_string_create(L"invalid deltype"); break;
			case 110: s = coco_string_create(L"invalid tchk_def"); break;
			case 111: s = coco_string_create(L"invalid te_def"); break;
			case 112: s = coco_string_create(L"invalid lbl_type"); break;
			case 113: s = coco_string_create(L"invalid del_def"); break;
			case 114: s = coco_string_create(L"invalid port_spec"); break;
			case 115: s = coco_string_create(L"invalid conditional_port_expr"); break;
			case 116: s = coco_string_create(L"invalid conditional_port_expr"); break;
			case 117: s = coco_string_create(L"invalid port_tchk"); break;
			case 118: s = coco_string_create(L"invalid timing_check_condition"); break;
			case 119: s = coco_string_create(L"invalid cns_def"); break;
			case 120: s = coco_string_create(L"invalid tenv_def"); break;
			case 121: s = coco_string_create(L"invalid real_number"); break;
			case 122: s = coco_string_create(L"invalid pos_or_neg_pair_"); break;
			case 123: s = coco_string_create(L"invalid edge_identifier"); break;
			case 124: s = coco_string_create(L"invalid unary_operator"); break;
			case 125: s = coco_string_create(L"invalid binary_operator"); break;
			case 126: s = coco_string_create(L"invalid equality_operator"); break;
			case 127: s = coco_string_create(L"invalid inversion_operator"); break;
			case 128: s = coco_string_create(L"invalid sign"); break;

		default:
		{
			s = QString( "generic error %1").arg(n);
		}
		break;
	}
    if( !str.isEmpty() )
        s = QString("%1 %2").arg(s).arg(str);
	if( err )
		err->error(Sdf::Errors::Syntax, sourcePath, line, col, s);
	else
		qCritical() << "Error Parser" << line << col << s;
	//count++;
}

} // namespace

